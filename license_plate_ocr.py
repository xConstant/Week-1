# -*- coding: utf-8 -*-
"""license_plate_ocr

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bBeJbI7JQMLESlqvu_kltTbE0hdK13Aj
"""

"""
License Plate OCR Module
Detects and reads license plates using OpenCV and Tesseract OCR
"""

import cv2
import numpy as np
import re

try:
    import pytesseract
    TESSERACT_AVAILABLE = True
except ImportError:
    TESSERACT_AVAILABLE = False
    print("Warning: pytesseract not installed. Install with: pip install pytesseract")

class LicensePlateOCR:
    def __init__(self, config):
        """
        Initialize license plate OCR

        Args:
            config: Configuration object
        """
        self.config = config
        self.tesseract_available = TESSERACT_AVAILABLE

        # Configure tesseract path if needed
        tesseract_cmd = config.get('tesseract_cmd', None)
        if tesseract_cmd and TESSERACT_AVAILABLE:
            pytesseract.pytesseract.tesseract_cmd = tesseract_cmd

        # Minimum plate dimensions
        self.min_plate_width = config.get('min_plate_width', 80)
        self.min_plate_height = config.get('min_plate_height', 20)
        self.max_plate_width = config.get('max_plate_width', 400)
        self.max_plate_height = config.get('max_plate_height', 150)

        # Aspect ratio range for license plates
        self.min_aspect_ratio = config.get('min_aspect_ratio', 2.0)
        self.max_aspect_ratio = config.get('max_aspect_ratio', 6.0)

    def detect_license_plates(self, frame):
        """
        Detect potential license plate regions in frame

        Args:
            frame: Input frame

        Returns:
            List of (x, y, w, h) tuples for detected plates
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Apply bilateral filter to reduce noise while keeping edges sharp
        blur = cv2.bilateralFilter(gray, 11, 17, 17)

        # Edge detection
        edges = cv2.Canny(blur, 30, 200)

        # Find contours
        contours, _ = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        # Sort contours by area (largest first)
        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:30]

        plate_candidates = []

        for contour in contours:
            # Approximate the contour
            perimeter = cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, 0.02 * perimeter, True)

            # License plates typically have 4 corners
            if len(approx) == 4:
                x, y, w, h = cv2.boundingRect(contour)

                # Check dimensions
                if (self.min_plate_width < w < self.max_plate_width and
                    self.min_plate_height < h < self.max_plate_height):

                    # Check aspect ratio
                    aspect_ratio = w / float(h)
                    if self.min_aspect_ratio < aspect_ratio < self.max_aspect_ratio:
                        plate_candidates.append((x, y, w, h))

        return plate_candidates

    def preprocess_plate(self, plate_img):
        """
        Preprocess license plate image for OCR

        Args:
            plate_img: Cropped plate image

        Returns:
            Preprocessed image
        """
        # Convert to grayscale
        if len(plate_img.shape) == 3:
            gray = cv2.cvtColor(plate_img, cv2.COLOR_BGR2GRAY)
        else:
            gray = plate_img

        # Resize for better OCR (height = 100 pixels)
        height, width = gray.shape
        new_height = 100
        new_width = int(width * (new_height / height))
        resized = cv2.resize(gray, (new_width, new_height))

        # Apply adaptive thresholding
        thresh = cv2.adaptiveThreshold(
            resized, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY, 11, 2
        )

        # Denoise
        denoised = cv2.fastNlMeansDenoising(thresh, None, 10, 7, 21)

        # Morphological operations to clean up
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        morph = cv2.morphologyEx(denoised, cv2.MORPH_CLOSE, kernel)

        return morph

    def read_plate_text(self, plate_img):
        """
        Read text from license plate image using OCR

        Args:
            plate_img: Preprocessed plate image

        Returns:
            Detected text string
        """
        if not self.tesseract_available:
            return "OCR_NOT_AVAILABLE"

        try:
            # Configure tesseract for license plate recognition
            # --psm 7: Treat image as single text line
            # --oem 3: Default OCR Engine Mode
            custom_config = r'--oem 3 --psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

            text = pytesseract.image_to_string(plate_img, config=custom_config)

            # Clean up the text
            text = text.strip().replace(' ', '').replace('\n', '')

            # Basic validation - license plates typically have alphanumeric characters
            if len(text) >= 4 and self.is_valid_plate(text):
                return text

            return ""

        except Exception as e:
            print(f"OCR Error: {e}")
            return ""

    def is_valid_plate(self, text):
        """
        Validate if text matches typical license plate patterns

        Args:
            text: Detected text

        Returns:
            True if valid plate format
        """
        # Remove any non-alphanumeric characters
        text = re.sub(r'[^A-Z0-9]', '', text.upper())

        # Check if it contains both letters and numbers
        has_letters = any(c.isalpha() for c in text)
        has_numbers = any(c.isdigit() for c in text)

        # Valid plate should have both letters and numbers, length 4-10
        return has_letters and has_numbers and 4 <= len(text) <= 10

    def process_frame(self, frame):
        """
        Process frame to detect and read all license plates

        Args:
            frame: Input frame

        Returns:
            List of dictionaries with plate info: [{'bbox': (x,y,w,h), 'text': 'ABC123'}, ...]
            annotated_frame: Frame with plate detections drawn
        """
        annotated_frame = frame.copy()
        plate_regions = self.detect_license_plates(frame)

        results = []

        for (x, y, w, h) in plate_regions:
            # Extract plate region
            plate_img = frame[y:y+h, x:x+w]

            # Preprocess
            processed = self.preprocess_plate(plate_img)

            # Read text
            text = self.read_plate_text(processed)

            if text:
                results.append({
                    'bbox': (x, y, w, h),
                    'text': text
                })

                # Draw on frame
                cv2.rectangle(annotated_frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
                cv2.putText(annotated_frame, text, (x, y-10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            else:
                # Draw as potential plate but unreadable
                cv2.rectangle(annotated_frame, (x, y), (x+w, y+h), (255, 0, 0), 1)

        return results, annotated_frame

    def match_plate_to_vehicle(self, vehicle_bbox, plate_results):
        """
        Match detected plates to vehicles based on spatial proximity

        Args:
            vehicle_bbox: (x, y, w, h) of vehicle
            plate_results: List of plate detection dictionaries

        Returns:
            Plate text if found, None otherwise
        """
        vx, vy, vw, vh = vehicle_bbox
        v_center_x = vx + vw // 2
        v_center_y = vy + vh // 2

        min_distance = float('inf')
        closest_plate = None

        for plate in plate_results:
            px, py, pw, ph = plate['bbox']
            p_center_x = px + pw // 2
            p_center_y = py + ph // 2

            # Check if plate is within vehicle bounding box or nearby
            if (vx <= p_center_x <= vx + vw and vy <= p_center_y <= vy + vh):
                distance = np.sqrt((v_center_x - p_center_x)**2 + (v_center_y - p_center_y)**2)

                if distance < min_distance:
                    min_distance = distance
                    closest_plate = plate['text']

        return closest_plate


def test_ocr():
    """Test function for license plate OCR"""
    import sys

    if len(sys.argv) < 2:
        print("Usage: python license_plate_ocr.py <image_path>")
        return

    from config import Config
    config = Config()

    ocr = LicensePlateOCR(config)

    # Read image
    image = cv2.imread(sys.argv[1])
    if image is None:
        print(f"Error: Could not read image {sys.argv[1]}")
        return

    # Process image
    results, annotated = ocr.process_frame(image)

    # Display results
    print(f"Found {len(results)} license plates:")
    for result in results:
        print(f"  Text: {result['text']}, BBox: {result['bbox']}")

    # Show image
    cv2.imshow("License Plate Detection", annotated)
    cv2.waitKey(0)
    cv2.destroyAllWindows()


if __name__ == "__main__":
    test_ocr()