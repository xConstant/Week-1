# -*- coding: utf-8 -*-
"""vehicle_detector

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zjW8zNUZrpQLBNxaxUjzY3jh0XAOg9Gm
"""

"""
Vehicle Detection Module
Uses YOLO or Background Subtraction for detecting vehicles
"""

import cv2
import numpy as np
from collections import defaultdict

class VehicleDetector:
    def __init__(self, config):
        """
        Initialize vehicle detector

        Args:
            config: Configuration object
        """
        self.config = config
        self.detection_method = config.get('detection_method', 'background_subtraction')
        self.trackers = {}
        self.next_id = 0
        self.max_disappeared = config.get('max_disappeared', 30)
        self.disappeared = defaultdict(int)

        if self.detection_method == 'yolo':
            self.init_yolo()
        else:
            self.init_background_subtraction()

    def init_yolo(self):
        """Initialize YOLO detector"""
        # Note: Requires yolov3.weights, yolov3.cfg, and coco.names files
        try:
            weights_path = self.config.get('yolo_weights', 'yolov3.weights')
            config_path = self.config.get('yolo_config', 'yolov3.cfg')
            names_path = self.config.get('yolo_names', 'coco.names')

            self.net = cv2.dnn.readNetFromDarknet(config_path, weights_path)
            self.net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
            self.net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)

            with open(names_path, 'r') as f:
                self.classes = [line.strip() for line in f.readlines()]

            self.vehicle_classes = ['car', 'truck', 'bus', 'motorbike']
            self.layer_names = self.net.getLayerNames()
            self.output_layers = [self.layer_names[i - 1] for i in self.net.getUnconnectedOutLayers()]

            print("YOLO detector initialized")
        except Exception as e:
            print(f"Error initializing YOLO: {e}")
            print("Falling back to background subtraction")
            self.detection_method = 'background_subtraction'
            self.init_background_subtraction()

    def init_background_subtraction(self):
        """Initialize background subtraction detector"""
        self.bg_subtractor = cv2.createBackgroundSubtractorMOG2(
            history=500,
            varThreshold=16,
            detectShadows=True
        )
        self.min_contour_area = self.config.get('min_contour_area', 500)
        print("Background subtraction detector initialized")

    def detect(self, frame):
        """
        Detect vehicles in frame

        Args:
            frame: Input frame

        Returns:
            List of detections [(x, y, w, h, confidence, track_id), ...]
        """
        if self.detection_method == 'yolo':
            return self.detect_yolo(frame)
        else:
            return self.detect_background_subtraction(frame)

    def detect_yolo(self, frame):
        """Detect vehicles using YOLO"""
        height, width = frame.shape[:2]

        # Create blob and perform detection
        blob = cv2.dnn.blobFromImage(frame, 1/255.0, (416, 416), swapRB=True, crop=False)
        self.net.setInput(blob)
        outputs = self.net.forward(self.output_layers)

        # Process detections
        boxes = []
        confidences = []
        class_ids = []

        for output in outputs:
            for detection in output:
                scores = detection[5:]
                class_id = np.argmax(scores)
                confidence = scores[class_id]

                if confidence > 0.5 and self.classes[class_id] in self.vehicle_classes:
                    center_x = int(detection[0] * width)
                    center_y = int(detection[1] * height)
                    w = int(detection[2] * width)
                    h = int(detection[3] * height)

                    x = int(center_x - w / 2)
                    y = int(center_y - h / 2)

                    boxes.append([x, y, w, h])
                    confidences.append(float(confidence))
                    class_ids.append(class_id)

        # Apply non-maximum suppression
        indices = cv2.dnn.NMSBoxes(boxes, confidences, 0.5, 0.4)

        detections = []
        if len(indices) > 0:
            for i in indices.flatten():
                x, y, w, h = boxes[i]
                detections.append((x, y, w, h, confidences[i], None))

        # Track detections
        return self.track_objects(detections)

    def detect_background_subtraction(self, frame):
        """Detect vehicles using background subtraction"""
        # Apply background subtraction
        fg_mask = self.bg_subtractor.apply(frame)

        # Remove shadows
        fg_mask[fg_mask == 127] = 0

        # Apply morphological operations
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_CLOSE, kernel)
        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)

        # Find contours
        contours, _ = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        detections = []
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > self.min_contour_area:
                x, y, w, h = cv2.boundingRect(contour)
                confidence = min(area / 10000, 1.0)  # Normalize confidence
                detections.append((x, y, w, h, confidence, None))

        # Track detections
        return self.track_objects(detections)

    def track_objects(self, detections):
        """
        Simple object tracking using centroid matching

        Args:
            detections: List of (x, y, w, h, confidence, None)

        Returns:
            List of (x, y, w, h, confidence, track_id)
        """
        if len(detections) == 0:
            # Mark existing objects as disappeared
            for track_id in list(self.trackers.keys()):
                self.disappeared[track_id] += 1
                if self.disappeared[track_id] > self.max_disappeared:
                    del self.trackers[track_id]
                    del self.disappeared[track_id]
            return []

        # Calculate centroids of current detections
        input_centroids = []
        for (x, y, w, h, conf, _) in detections:
            cx = x + w // 2
            cy = y + h // 2
            input_centroids.append((cx, cy))
        input_centroids = np.array(input_centroids)

        # If no tracked objects, register all as new
        if len(self.trackers) == 0:
            tracked_detections = []
            for i, (x, y, w, h, conf, _) in enumerate(detections):
                track_id = self.next_id
                self.trackers[track_id] = input_centroids[i]
                self.disappeared[track_id] = 0
                self.next_id += 1
                tracked_detections.append((x, y, w, h, conf, track_id))
            return tracked_detections

        # Get existing tracked centroids
        track_ids = list(self.trackers.keys())
        tracked_centroids = np.array([self.trackers[tid] for tid in track_ids])

        # Compute distance matrix
        distances = np.linalg.norm(tracked_centroids[:, None] - input_centroids[None, :], axis=2)

        # Find minimum distances
        rows = distances.min(axis=1).argsort()
        cols = distances.argmin(axis=1)[rows]

        used_rows = set()
        used_cols = set()
        tracked_detections = []

        # Match existing objects to detections
        for (row, col) in zip(rows, cols):
            if row in used_rows or col in used_cols:
                continue

            if distances[row, col] > 100:  # Maximum distance threshold
                continue

            track_id = track_ids[row]
            self.trackers[track_id] = input_centroids[col]
            self.disappeared[track_id] = 0

            x, y, w, h, conf, _ = detections[col]
            tracked_detections.append((x, y, w, h, conf, track_id))

            used_rows.add(row)
            used_cols.add(col)

        # Handle unmatched tracked objects
        unused_rows = set(range(distances.shape[0])) - used_rows
        for row in unused_rows:
            track_id = track_ids[row]
            self.disappeared[track_id] += 1
            if self.disappeared[track_id] > self.max_disappeared:
                del self.trackers[track_id]
                del self.disappeared[track_id]

        # Register new detections
        unused_cols = set(range(distances.shape[1])) - used_cols
        for col in unused_cols:
            track_id = self.next_id
            self.trackers[track_id] = input_centroids[col]
            self.disappeared[track_id] = 0
            self.next_id += 1

            x, y, w, h, conf, _ = detections[col]
            tracked_detections.append((x, y, w, h, conf, track_id))

        return tracked_detections