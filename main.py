# -*- coding: utf-8 -*-
"""main.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y8IpU4kp9LbjRUWI-QIjyGfzm7XRN058
"""

"""
Traffic Violation Detection System
Main execution file for detecting traffic violations in video streams
"""

import cv2
import numpy as np
from vehicle_detector import VehicleDetector
from violation_monitor import ViolationMonitor
from config import Config
import argparse
import os
from datetime import datetime

class TrafficViolationSystem:
    def __init__(self, video_source, config_file=None):
        """
        Initialize the traffic violation detection system

        Args:
            video_source: Path to video file or camera index
            config_file: Path to configuration file
        """
        self.config = Config(config_file)
        self.video_source = video_source
        self.vehicle_detector = VehicleDetector(self.config)
        self.violation_monitor = ViolationMonitor(self.config)

        # Setup output directory
        self.output_dir = self.config.get('output_dir', 'violations')
        os.makedirs(self.output_dir, exist_ok=True)

    def process_video(self):
        """Process video and detect violations"""
        cap = cv2.VideoCapture(self.video_source)

        if not cap.isOpened():
            print(f"Error: Could not open video source {self.video_source}")
            return

        # Get video properties
        fps = int(cap.get(cv2.CAP_PROP_FPS))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

        print(f"Processing video: {width}x{height} @ {fps}fps")
        print("Press 'q' to quit, 's' to save current frame, 'r' to toggle recording")

        # Video writer for saving output
        output_path = None
        out = None
        recording = self.config.get('auto_record', False)

        if recording:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = os.path.join(self.output_dir, f'output_{timestamp}.avi')
            fourcc = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
            print(f"Recording to: {output_path}")

        frame_count = 0

        while True:
            ret, frame = cap.read()
            if not ret:
                print("End of video or cannot read frame")
                break

            frame_count += 1

            # Detect vehicles
            detections = self.vehicle_detector.detect(frame)

            # Monitor for violations
            violations, annotated_frame = self.violation_monitor.check_violations(
                frame, detections, frame_count
            )

            # Save violation snapshots
            if violations:
                for violation in violations:
                    self.save_violation(annotated_frame, violation, frame_count)

            # Write frame to output video if recording
            if recording and out is not None:
                out.write(annotated_frame)

            # Display frame
            cv2.imshow('Traffic Violation Detection', annotated_frame)

            # Handle key presses
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                break
            elif key == ord('s'):
                self.save_frame(annotated_frame, frame_count)
            elif key == ord('r'):
                recording = not recording
                if recording and out is None:
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    output_path = os.path.join(self.output_dir, f'output_{timestamp}.avi')
                    fourcc = cv2.VideoWriter_fourcc(*'XVID')
                    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
                    print(f"Started recording to: {output_path}")
                elif not recording and out is not None:
                    out.release()
                    out = None
                    print("Stopped recording")

        # Cleanup
        cap.release()
        if out is not None:
            out.release()
        cv2.destroyAllWindows()

        # Print summary
        self.violation_monitor.print_summary()

    def save_violation(self, frame, violation, frame_num):
        """Save violation snapshot"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"violation_{violation['type']}_{timestamp}_frame{frame_num}.jpg"
        filepath = os.path.join(self.output_dir, filename)
        cv2.imwrite(filepath, frame)
        print(f"Violation saved: {filepath}")

    def save_frame(self, frame, frame_num):
        """Save current frame"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"frame_{timestamp}_{frame_num}.jpg"
        filepath = os.path.join(self.output_dir, filename)
        cv2.imwrite(filepath, frame)
        print(f"Frame saved: {filepath}")

def main():
    parser = argparse.ArgumentParser(description='Traffic Violation Detection System')
    parser.add_argument('--video', type=str, default='0',
                        help='Path to video file or camera index (default: 0)')
    parser.add_argument('--config', type=str, default=None,
                        help='Path to configuration file')

    args = parser.parse_args()

    # Convert camera index to integer if applicable
    video_source = args.video
    if video_source.isdigit():
        video_source = int(video_source)

    # Initialize and run system
    system = TrafficViolationSystem(video_source, args.config)
    system.process_video()

if __name__ == "__main__":
    main()