# -*- coding: utf-8 -*-
"""violation_monitor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QHXQNWmo5ZuB0EiU-jq5vHt5uK1T_sq5
"""

"""
Violation Monitor Module
Monitors vehicles for traffic violations (red light, lane crossing, speeding)
"""

import cv2
import numpy as np
from collections import defaultdict, deque
from datetime import datetime

class ViolationMonitor:
    def __init__(self, config):
        """
        Initialize violation monitor

        Args:
            config: Configuration object
        """
        self.config = config

        # Traffic light state
        self.traffic_light_state = 'RED'  # Can be 'RED', 'YELLOW', 'GREEN'
        self.light_cycle_frames = config.get('light_cycle_frames', 300)
        self.frame_counter = 0

        # Stop line (y-coordinate where vehicles should stop)
        self.stop_line_y = config.get('stop_line_y', None)

        # Lane boundaries
        self.lane_boundaries = config.get('lane_boundaries', None)

        # Vehicle tracking
        self.vehicle_positions = defaultdict(lambda: deque(maxlen=30))
        self.violations = defaultdict(list)
        self.violation_count = defaultdict(int)

        # Speed estimation
        self.pixel_to_meter = config.get('pixel_to_meter', 0.05)  # Calibration needed
        self.fps = config.get('fps', 30)
        self.speed_limit = config.get('speed_limit_kmh', 60)

        # Drawing colors
        self.color_red = (0, 0, 255)
        self.color_green = (0, 255, 0)
        self.color_yellow = (0, 255, 255)
        self.color_blue = (255, 0, 0)

    def set_stop_line(self, y_coordinate):
        """Set the stop line y-coordinate"""
        self.stop_line_y = y_coordinate

    def set_lane_boundaries(self, boundaries):
        """
        Set lane boundaries

        Args:
            boundaries: List of x-coordinates defining lane boundaries
        """
        self.lane_boundaries = boundaries

    def toggle_traffic_light(self):
        """Toggle traffic light state (for simulation)"""
        states = ['RED', 'YELLOW', 'GREEN']
        current_idx = states.index(self.traffic_light_state)
        self.traffic_light_state = states[(current_idx + 1) % 3]
        print(f"Traffic light changed to: {self.traffic_light_state}")

    def check_violations(self, frame, detections, frame_num):
        """
        Check for traffic violations

        Args:
            frame: Input frame
            detections: List of (x, y, w, h, confidence, track_id)
            frame_num: Current frame number

        Returns:
            violations: List of violation dictionaries
            annotated_frame: Frame with annotations
        """
        annotated_frame = frame.copy()
        height, width = frame.shape[:2]

        # Auto-set stop line if not set
        if self.stop_line_y is None:
            self.stop_line_y = int(height * 0.6)

        # Auto-cycle traffic light for simulation
        if self.frame_counter % self.light_cycle_frames == 0:
            self.toggle_traffic_light()
        self.frame_counter += 1

        # Draw stop line
        cv2.line(annotated_frame, (0, self.stop_line_y),
                (width, self.stop_line_y), self.color_red, 3)
        cv2.putText(annotated_frame, "STOP LINE", (10, self.stop_line_y - 10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, self.color_red, 2)

        # Draw lane boundaries if set
        if self.lane_boundaries:
            for x in self.lane_boundaries:
                cv2.line(annotated_frame, (x, 0), (x, height),
                        self.color_yellow, 2, cv2.LINE_DOTTED)

        # Draw traffic light indicator
        light_color = self.color_red if self.traffic_light_state == 'RED' else \
                     self.color_yellow if self.traffic_light_state == 'YELLOW' else \
                     self.color_green
        cv2.circle(annotated_frame, (width - 50, 50), 25, light_color, -1)
        cv2.circle(annotated_frame, (width - 50, 50), 25, (255, 255, 255), 2)
        cv2.putText(annotated_frame, self.traffic_light_state, (width - 90, 100),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, light_color, 2)

        violations = []

        for detection in detections:
            x, y, w, h, conf, track_id = detection

            if track_id is None:
                continue

            # Calculate vehicle center
            center_x = x + w // 2
            center_y = y + h // 2
            bottom_y = y + h

            # Store vehicle position
            self.vehicle_positions[track_id].append((center_x, center_y, bottom_y, frame_num))

            # Draw bounding box
            color = self.color_green
            violation_text = []

            # Check for red light violation
            if self.traffic_light_state == 'RED':
                if self.check_red_light_violation(track_id, bottom_y):
                    color = self.color_red
                    violation_text.append("RED LIGHT")
                    if 'red_light' not in self.violations[track_id]:
                        self.violations[track_id].append('red_light')
                        self.violation_count['red_light'] += 1
                        violations.append({
                            'type': 'red_light',
                            'track_id': track_id,
                            'position': (center_x, center_y),
                            'timestamp': datetime.now().isoformat()
                        })

            # Check for lane violation
            if self.lane_boundaries and self.check_lane_violation(center_x):
                color = self.color_red
                violation_text.append("LANE VIOLATION")
                if 'lane' not in self.violations[track_id]:
                    self.violations[track_id].append('lane')
                    self.violation_count['lane'] += 1
                    violations.append({
                        'type': 'lane',
                        'track_id': track_id,
                        'position': (center_x, center_y),
                        'timestamp': datetime.now().isoformat()
                    })

            # Check for speeding
            speed = self.estimate_speed(track_id)
            if speed and speed > self.speed_limit:
                color = self.color_red
                violation_text.append(f"SPEEDING {speed:.1f}km/h")
                if 'speeding' not in self.violations[track_id]:
                    self.violations[track_id].append('speeding')
                    self.violation_count['speeding'] += 1
                    violations.append({
                        'type': 'speeding',
                        'track_id': track_id,
                        'speed': speed,
                        'position': (center_x, center_y),
                        'timestamp': datetime.now().isoformat()
                    })

            # Draw detection box
            cv2.rectangle(annotated_frame, (x, y), (x + w, y + h), color, 2)

            # Draw track ID and violations
            label = f"ID:{track_id}"
            if speed:
                label += f" {speed:.0f}km/h"
            cv2.putText(annotated_frame, label, (x, y - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

            # Draw violation text
            for i, vtext in enumerate(violation_text):
                cv2.putText(annotated_frame, vtext, (x, y + h + 20 + i*20),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, self.color_red, 2)

        # Draw violation summary
        y_offset = 30
        cv2.putText(annotated_frame, f"Total Violations:", (10, y_offset),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        y_offset += 25
        for vtype, count in self.violation_count.items():
            cv2.putText(annotated_frame, f"{vtype}: {count}", (10, y_offset),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            y_offset += 20

        return violations, annotated_frame

    def check_red_light_violation(self, track_id, bottom_y):
        """
        Check if vehicle crossed stop line during red light

        Args:
            track_id: Vehicle track ID
            bottom_y: Bottom y-coordinate of vehicle bounding box

        Returns:
            True if violation detected
        """
        if len(self.vehicle_positions[track_id]) < 2:
            return False

        # Get previous and current positions
        positions = list(self.vehicle_positions[track_id])
        prev_bottom_y = positions[-2][2]
        curr_bottom_y = positions[-1][2]

        # Check if vehicle crossed the stop line
        if prev_bottom_y < self.stop_line_y and curr_bottom_y >= self.stop_line_y:
            return True

        return False

    def check_lane_violation(self, center_x):
        """
        Check if vehicle is outside lane boundaries

        Args:
            center_x: Vehicle center x-coordinate

        Returns:
            True if violation detected
        """
        if not self.lane_boundaries or len(self.lane_boundaries) < 2:
            return False

        # Check if vehicle is within any lane
        for i in range(len(self.lane_boundaries) - 1):
            if self.lane_boundaries[i] <= center_x <= self.lane_boundaries[i + 1]:
                return False

        return True

    def estimate_speed(self, track_id):
        """
        Estimate vehicle speed based on position history

        Args:
            track_id: Vehicle track ID

        Returns:
            Speed in km/h or None
        """
        if len(self.vehicle_positions[track_id]) < 10:
            return None

        positions = list(self.vehicle_positions[track_id])

        # Get positions from 10 frames ago and current
        old_pos = positions[-10]
        new_pos = positions[-1]

        # Calculate distance in pixels
        dx = new_pos[0] - old_pos[0]
        dy = new_pos[1] - old_pos[1]
        distance_pixels = np.sqrt(dx**2 + dy**2)

        # Convert to meters
        distance_meters = distance_pixels * self.pixel_to_meter

        # Calculate time elapsed (10 frames)
        time_seconds = 10 / self.fps

        # Calculate speed in m/s and convert to km/h
        speed_ms = distance_meters / time_seconds
        speed_kmh = speed_ms * 3.6

        return speed_kmh

    def print_summary(self):
        """Print violation summary"""
        print("\n" + "="*50)
        print("VIOLATION SUMMARY")
        print("="*50)
        print(f"Total Vehicles Tracked: {len(self.violations)}")
        print(f"\nViolation Counts:")
        for vtype, count in self.violation_count.items():
            print(f"  {vtype.upper()}: {count}")
        print("="*50)